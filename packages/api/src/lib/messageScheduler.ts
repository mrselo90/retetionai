/**
 * Message scheduling utilities
 * Schedule WhatsApp messages for post-purchase care
 */

import { getSupabaseServiceClient } from '@glowguide/shared';
import { scheduleMessage } from '../queues.js';
import { decryptPhone } from './encryption.js';
import type { ScheduledMessageJobData } from '@glowguide/shared';

export interface ScheduleMessageOptions {
  userId: string;
  orderId?: string;
  merchantId: string;
  messageType: 'welcome' | 'checkin_t3' | 'checkin_t14' | 'upsell';
  scheduledFor: Date;
  messageTemplate?: string;
}

/**
 * Schedule a message for a user
 */
export async function scheduleUserMessage(
  options: ScheduleMessageOptions
): Promise<{ taskId: string; jobId: string }> {
  const serviceClient = getSupabaseServiceClient();

  // Get user phone number (decrypt)
  const { data: user, error: userError } = await serviceClient
    .from('users')
    .select('id, phone')
    .eq('id', options.userId)
    .eq('merchant_id', options.merchantId)
    .single();

  if (userError || !user) {
    throw new Error('User not found');
  }

  // Decrypt phone
  const phoneNumber = decryptPhone(user.phone);

  // Create scheduled task in database
  const { data: task, error: taskError } = await serviceClient
    .from('scheduled_tasks')
    .insert({
      user_id: options.userId,
      order_id: options.orderId || null,
      task_type: options.messageType,
      execute_at: options.scheduledFor.toISOString(),
      status: 'pending',
    })
    .select('id')
    .single();

  if (taskError || !task) {
    throw new Error(`Failed to create scheduled task: ${taskError?.message}`);
  }

  // Add to BullMQ queue
  const job = await scheduleMessage({
    type: options.messageType,
    userId: options.userId,
    orderId: options.orderId,
    merchantId: options.merchantId,
    to: phoneNumber,
    message: options.messageTemplate || '', // Will be generated by worker if empty
    scheduledFor: options.scheduledFor.toISOString(),
  });

  return {
    taskId: task.id,
    jobId: String(job.id),
  };
}

/**
 * Schedule post-delivery messages for an order
 * T+3: Check-in message
 * T+14: Follow-up + upsell
 */
export async function scheduleOrderMessages(
  orderId: string,
  merchantId: string,
  deliveryDate: Date
): Promise<{ tasks: Array<{ taskId: string; jobId: string }> }> {
  // Get order with user
  const serviceClient = getSupabaseServiceClient();

  const { data: order, error: orderError } = await serviceClient
    .from('orders')
    .select('id, user_id, delivery_date')
    .eq('id', orderId)
    .eq('merchant_id', merchantId)
    .single();

  if (orderError || !order) {
    throw new Error('Order not found');
  }

  const tasks: Array<{ taskId: string; jobId: string }> = [];

  // T+3: Check-in message (3 days after delivery)
  const checkinT3Date = new Date(deliveryDate);
  checkinT3Date.setDate(checkinT3Date.getDate() + 3);

  try {
    const t3Task = await scheduleUserMessage({
      userId: order.user_id,
      orderId: order.id,
      merchantId,
      messageType: 'checkin_t3',
      scheduledFor: checkinT3Date,
    });
    tasks.push(t3Task);
  } catch (error) {
    console.error('Failed to schedule T+3 message:', error);
  }

  // T+14: Follow-up + upsell (14 days after delivery)
  const checkinT14Date = new Date(deliveryDate);
  checkinT14Date.setDate(checkinT14Date.getDate() + 14);

  try {
    const t14Task = await scheduleUserMessage({
      userId: order.user_id,
      orderId: order.id,
      merchantId,
      messageType: 'checkin_t14',
      scheduledFor: checkinT14Date,
    });
    tasks.push(t14Task);
  } catch (error) {
    console.error('Failed to schedule T+14 message:', error);
  }

  return { tasks };
}

/**
 * Cancel scheduled messages for an order
 */
export async function cancelOrderMessages(
  orderId: string
): Promise<{ cancelled: number }> {
  const serviceClient = getSupabaseServiceClient();

  // Update scheduled tasks to cancelled
  const { data, error } = await serviceClient
    .from('scheduled_tasks')
    .update({ status: 'cancelled' })
    .eq('order_id', orderId)
    .eq('status', 'pending')
    .select('id');

  if (error) {
    throw new Error(`Failed to cancel messages: ${error.message}`);
  }

  // FUTURE: Also cancel BullMQ jobs (requires storing job IDs in scheduled_tasks table)
  // Current implementation: Jobs will check task status before executing
  // If status is 'cancelled', the job will skip execution

  return { cancelled: data?.length || 0 };
}

/**
 * Get scheduled messages for a user
 */
export async function getUserScheduledMessages(
  userId: string,
  merchantId: string
): Promise<any[]> {
  const serviceClient = getSupabaseServiceClient();

  const { data: tasks, error } = await serviceClient
    .from('scheduled_tasks')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'pending')
    .order('execute_at', { ascending: true });

  if (error) {
    throw new Error(`Failed to get scheduled messages: ${error.message}`);
  }

  return tasks || [];
}
